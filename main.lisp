;;;; P(author=Ilan Moscovitz) = (0, 1)
;;;; LISP implementation of Neapolitan's (1990) Bayesian Inference Algorithm

(defun example1 ()
  (let* ((C nil)
         (D nil)
         (root 'D)
         (nodes '(C D)))
;; set up C
    (setf (get 'C 'parent) 'D)
    (setf (get 'C 'children) nil)
    (setf (get 'C 'instantiated) nil)
    (setf (get 'C 'CPT) (make-array '(2 2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'C 'CPT) 0 0) .5)
    (setf (aref (get 'C 'CPT) 0 1) .25)
    (setf (aref (get 'C 'CPT) 1 0) .5)
    (setf (aref (get 'C 'CPT) 1 1) .75)
    (setf (get 'C 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; set up D

    (setf (get 'D 'parent) nil)
    (setf (get 'D 'children) '(C))
    (setf (get 'D 'instantiated) nil)
    (setf (get 'D 'CPT) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'D 'CPT) 0) .9)
    (setf (aref (get 'D 'CPT) 1) .1)
    (setf (get 'D 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; let's roll

    (print-network nodes)
    (initialize root)
    (print-network nodes)
    (instantiate 'C 1)
    (print-network nodes)
    (format t "~&~s" (aref (get 'D 'probs) 1))))

(defun example2 ()
  (let* ((A nil)
         (B nil)
         (C nil)
         (D nil)
         (root 'A)
         (nodes '(C B D A)))
;; set up C
    (setf (get 'C 'parent) 'B)
    (setf (get 'C 'children) nil)
    (setf (get 'C 'instantiated) nil)
    (setf (get 'C 'CPT) (make-array '(2 2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'C 'CPT) 0 0) .4)
    (setf (aref (get 'C 'CPT) 0 1) .001)
    (setf (aref (get 'C 'CPT) 1 0) .6)
    (setf (aref (get 'C 'CPT) 1 1) .999)
    (setf (get 'C 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'C 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; set up B
    (setf (get 'B 'parent) 'A)
    (setf (get 'B 'children) '(C))
    (setf (get 'B 'instantiated) nil)
    (setf (get 'B 'CPT) (make-array '(2 2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'B 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'B 'CPT) 0 0) .7)
    (setf (aref (get 'B 'CPT) 0 1) .2)
    (setf (aref (get 'B 'CPT) 1 0) .3)
    (setf (aref (get 'B 'CPT) 1 1) .8)
    (setf (get 'B 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'B 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'B 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'B 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; set up D
    (setf (get 'D 'parent) 'A)
    (setf (get 'D 'children) nil)
    (setf (get 'D 'instantiated) nil)
    (setf (get 'D 'CPT) (make-array '(2 2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'D 'CPT) 0 0) .8)
    (setf (aref (get 'D 'CPT) 0 1) .4)
    (setf (aref (get 'D 'CPT) 1 0) .2)
    (setf (aref (get 'D 'CPT) 1 1) .6)
    (setf (get 'D 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'D 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; set up A

    (setf (get 'A 'parent) nil)
    (setf (get 'A 'children) '(B D))
    (setf (get 'A 'instantiated) nil)
    (setf (get 'A 'CPT) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (aref (get 'A 'CPT) 0) .1)
    (setf (aref (get 'A 'CPT) 1) .9)
    (setf (get 'A 'probs) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'A 'lambda-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'A 'lambda-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'A 'pi-values) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))
    (setf (get 'A 'pi-messages) (make-array '(2) :element-type 'double-float :initial-element 0.0d0))

;; let's roll

    (print-network nodes)
    (initialize root)
    (print-network nodes)
    (instantiate 'C 0)
    (print-network nodes)
    (format t "~&~s" (aref (get 'D 'probs) 0))))

(defun initialize (root)
  (init-lambdas root)
  (init-root root)
  (init-pi-messages root))

(defun formula1 (child)
  (let ((newarray (make-array (list (array-dimension (get child 'lambda-messages) 0)) :element-type 'double-float :initial-element 0.0d0)))
    (dotimes (j (array-dimension (get child 'lambda-messages) 0) newarray)
      (setf (aref newarray j)
        (do* ((k (array-dimension (get child 'CPT) 0))
              (i 0 (+ 1 i))
              (sumproducts 0))
             ((= i k) sumproducts)
             (setf sumproducts (+ sumproducts (+
                                 (* (aref (get child 'CPT) i j)
                                    (aref (get child 'lambda-values) i)))))                                    )))))

(defun formula2 (parent child)
    (if (not (null (get parent 'instantiated)))
      (copy-vector (get parent 'probs))
      (divide-vectors (get parent 'probs) (get child 'lambda-messages))))

(defun formula3 (node)
  (let ((newarray (make-array (list (array-dimension (get node 'lambda-values) 0)) :element-type 'double-float :initial-element 0.0d0)))
    (if (not (null (get node 'instantiated)))
        (setf newarray (copy-vector (get node 'probs)))
        (dotimes (i (array-dimension (get node 'lambda-values) 0) newarray)
          (setf (aref newarray i)
            (let ((product 1))
              (dolist (child (get node 'children) product)
                (setf product (* product (aref (get child 'lambda-messages) i))))))))))

(defun formula4 (parent child)
  (let ((newarray (make-array (list (array-dimension (get child 'pi-values) 0)) :element-type 'double-float :initial-element 0.0d0)))
    ; is j->m probs or cpt?
    (dotimes (i (array-dimension (get child 'probs) 0) newarray)
      (setf (aref newarray i)
        (do* ((m (array-dimension (get parent 'probs) 0) )
              (j 0 (+ 1 j))
              (sum 0))
              ((= j m) sum)
              (setf sum (+ sum (* (aref (get child 'CPT) i j)
                                  (aref (get child 'pi-messages) j)))))))))

(defun formula5 (node)
  (let* ((alpha 0)
         (k (array-dimension (get node 'probs) 0))
         (newarray
    (do* ((newarray (make-array (list k) :element-type 'double-float :initial-element 0.0d0))
          (i 0 (+ 1 i))
          (product))
          ((= i k) newarray)
            (setf product (* (aref (get node 'lambda-values) i) (aref (get node 'pi-values) i)))
            (setf alpha (+ alpha product))
            (setf (aref newarray i) product))))
    (setf alpha (/ 1 alpha))
    (dotimes (i k newarray)
      (setf (aref newarray i) (* (aref newarray i) alpha)))))

(defun instantiate (node element)
  (setf (get node 'instantiated) t)
  (dotimes (i (array-dimension (get node 'probs) 0))
    (if (= i element)
        (setf (aref (get node 'probs) i) 1)
        (setf (aref (get node 'probs) i) 0)))
  (setf (get node 'lambda-values) (formula3 node))
  (setf (get node 'lambda-messages) (formula1 node))
  (if (not (null (get node 'parent)))
      (update-rule-B node (get node 'parent)))
  (if (not (null (get node 'children)))
    (dolist (child (get node 'children))
      (setf (get child 'pi-messages) (formula2 node child))
      (update-rule-C node child))))

(defun update-rule-B (child parent)
  (if (null (get parent 'instantiated))
    (progn
      (setf (get parent 'lambda-values) (formula3 parent))
      (setf (get parent 'probs) (formula5 parent))
      (if (not (null (get parent 'parent)))
        (progn
          (setf (get parent 'lambda-messages) (formula1 parent))
          (update-rule-B parent (get parent 'parent))))
      (if (> (length (get parent 'children)) 1)
        (dolist (sibling (remove child (get parent 'children)))
          (setf (get sibling 'pi-messages) (formula2 parent sibling))
          (update-rule-C parent sibling))))))

(defun update-rule-C (parent child)
  (if (null (get child 'instantiated))
    (progn
      (setf (get child 'pi-values) (formula4 parent child))
      (setf (get child 'probs) (formula5 child))
      (do* ((rem-grandchildren (get child 'children) (cdr rem-grandchildren))
            (grandchild (car rem-grandchildren) (car rem-grandchildren)))
           ((null rem-grandchildren))
           (setf (get grandchild 'pi-messages) (formula2 child grandchild))
           (update-rule-C child grandchild)))))

(defun init-lambdas (node)
  (dotimes (i (array-dimension (get node 'lambda-messages) 0))
    (setf (aref (get node 'lambda-messages) i) '1)
    (setf (aref (get node 'lambda-values) i) '1))
  (do* ((rem-children (get node 'children) (cdr rem-children)))
       ((null rem-children))
       (init-lambdas (car rem-children))))

(defun init-root (root)
  (dotimes (i (array-dimension (get root 'CPT) 0))
    (setf (aref (get root 'probs) i) (aref (get root 'CPT) i))
    (setf (aref (get root 'pi-values) i) (aref (get root 'probs) i))))

(defun init-pi-messages (root)
  (do* ((rem-children (get root 'children) (cdr rem-children))
        (child (car rem-children) (car rem-children)))
       ((null rem-children))
        (setf (get child 'pi-messages) (formula2 root child))
        (update-rule-C root child)))

(defun multiply-vectors (array1 array2)
  (let ((newarray (make-array (list (array-dimension array1 0)) :element-type 'double-float)))
    (dotimes (i (array-dimension array1 0) newarray)
      (setf (aref newarray i) (* (aref array1 i) (aref array2 i))))))

(defun copy-vector (array)
  (let ((newarray (make-array (list (array-dimension array 0)) :element-type 'double-float :initial-element 0.0d0)))
    (dotimes (i (array-dimension array 0) newarray)
      (setf (aref newarray i) (aref array i)))))

(defun divide-vectors (array1 array2)
  (let ((newarray (make-array (list (array-dimension array1 0)) :element-type 'double-float)))
    (dotimes (i (array-dimension array1 0) newarray)
      (setf (aref newarray i) (/ (aref array1 i) (aref array2 i))))))

(defun print-network (nodes)
  (format t "~& ")
  (format t "~& ")
  (dolist (n nodes)
    (format t "~& ")
    (format t "~&NODE ~s" n)
    (format t "~&Parent ~s" (get n 'parent))
    (format t "~&Children ~s" (get n 'children))
    (format t "~&Instantiated ~s" (get n 'instantiated))
    (format t "~&Probs ~s" (get n 'probs))
    (format t "~&CPT ~s" (get n 'CPT))
    (format t "~&Lambda-values ~s" (get n 'lambda-values))
    (format t "~&Lambda-messages ~s" (get n 'lambda-messages))
    (format t "~&Pi-values ~s" (get n 'pi-values))
    (format t "~&Pi-messages ~s" (get n 'pi-messages))))
